---
title: "zoop 实现原理分析"
author: 朱亚东
date: 2024-08-12T14:31:22+08:00
---

# zoop 是什么
zoop 是 zig 的一个 OOP 解决方案，详细信息可以看看 [zoop官网](https://zhuyadong.github.io/zoop-docs/)

# 预设场景
本文的讨论基于如下的属于 `mymod` 模块的类和接口：
```zig
/// 接口 IGetName
pub const IGetName = struct {
    pub const Vtable = zoop.DevVtable(@This(), struct {
        getName: *const fn(self: *anyopaque) []const u8,
    });
    pub usingnamespace zoop.Api(@This());

    ptr: *anyopaque,
    vptr: *const Vtable,

    pub fn Api(comptime I:type) type {
        return struct {
            pub fn getName(self: I) []const u8 {
                return self.vptr.getName(self.ptr);
            }
        }
    }
}

/// 接口 ISetName
pub const ISetName = struct {
    pub const Vtable = zoop.DevVtable(@This(), struct {
        setName: *const fn(self: *anyopaque, name: []const u8) void,
    });
    pub usingnamespace zoop.Api(@This());

    ptr: *anyopaque,
    vptr: *const Vtable,

    pub fn Api(comptime I:type) type {
        return struct {
            pub fn setName(self: I, name: []const u8) void {
                self.vptr.setName(self.ptr, name);
            }
        }
    }
}

/// 基类 Base
pub const Base = struct {
    pub const extends = .{ISetName};
    pub usingnamespace zoop.Fn(@This());

    name: []const u8,
    mixin: zoop.Mixin(@This()),

    pub fn Fn(comptime T: type) type {
        return zoop.Method(.{
            struct {
                pub fn setName(this: *T, name: []const u8) void {
                    this.cast(Base).name = name;
                }
            },
        });
    }
}

/// 子类 Child
pub const Child = struct {
    pub const extends = .{Base, IGetName};
    pub usingnamespace zoop.Fn(@This());

    mixin: zoop.Mixin(@This()),

    pub fn Fn(comptime T: type) type {
        return zoop.Method(.{
            struct {
                pub fn getName(this: *T) []const u8 {
                    return this.cast(Base).name;
                }
            },
        });
    }
}
```

接口有两个:
- `IGetName`: 接口方法 `getName`
- `ISetName`: 接口方法 `setName`

类有两个:
- `Base`: 基类，实现接口 `ISetName`
- `Child`: 子类，继承 `Base`，并实现接口 `IGetName`

# 核心数据结构 `zoop.Mixin(T)`
我们看看两个类的 `mixin` 这个数据里面有什么：
```zig
pub const VtableFunc = *const fn (ifacename: []const u8) ?*IObject.Vtable;
pub const SuperPtrFunc = *const fn (rootptr: *anyopaque, typename: []const u8) ?*anyopaque;

zoop.Mixin(Base) = struct {
    deallocator: ?std.mem.Allocator = null,
    meta: struct {
        rootptr: ?*anyopaque = null,
        typeinfo: *struct {
            typename: []const u8,
            getVtable: VtableFunc,
            getSuperPtr: SuperPtrFunc,
        },
    },
    data: struct {},
}

zoop.Mixin(Child) = struct {
    deallocator: ?std.mem.Allocator = null,
    meta: struct {
        rootptr: ?*anyopaque = null,
        typeinfo: *struct {
            typename: []const u8,
            getVtable: VtableFunc,
            getSuperPtr: SuperPtrFunc,
        },
    },
    data: struct {
        mymod_Base: Base,
    },
}
```
可以看出，两者的唯一的差别在于 `Child.mixin.data` 里面包含了一个 `Base`, 而 `Base.mixin.data` 里面是空的。说明在 zoop 中，类有多少个父类，则类的 `mixin.data` 中，就有多少个父类的数据。

我们再来看看 `mixin.meta` 这个数据。先看看 `rootptr` 这个字段，如果我们现在有一个 `Base` 对象 `base`，那么 `base.mixin.meta.rootptr == &base` 是成立的；如果现在有一个 `Child` 对象 `child`，那么如下两条成立：
- `child.mixin.meta.rootptr == &child`
- `child.mixin.data.mymod_Base.mixin.meta.rootptr == &child`

事实上，`child.mixin.data.mymod_Base.mixin.meta` 里面的内容就是完全复制的 `child.mixin.meta`，因为所有内层对象的 `mixin.meta` 都是复制的最外层那个对象的 `mixin.meta`，因而所有对象的 `rootptr` 都指向最外层对象，这也是为什么叫 `rootptr` 的原因。

再看看 `typeinfo` 字段，这个字段是一个有3个字段的结构：
- `typename`: 这是 `rootptr` 指向对象的类型名
- `getVtable`: 根据接口名获得接口 `Vtable` 的函数
- `getSuperPtr`: 根据父类名获得 `mixin.data` 中父类指针

上面两个函数获取的都是最外层对象的数据。根据对 `mixin` 数据的分析，zoop 的类型转换的原理就很清楚了，大家可以参考官网上关于 [类型转换](https://zhuyadong.github.io/zoop-docs/guide/as-cast) 的内容。

# 动态构造类的方法、接口方法、和 `Vtable`
OOP 概念中的继承，重写，虚函数，实质其实就是在编译时动态构造需要的方法和属性。zoop 中主要是通过通过 [zoop.tuple](https://zhuyadong.github.io/zoop-docs/reference/tuple) 这个模块来进行编译时动态构造。

这部分需要大家有一定的 [zig comptime](https://ziglang.org/documentation/0.13.0/#comptime) 的知识，同时如果大家理解了这部分知识，那么 zoop 动态构造方法属性的部分实际不难理解。（建议同时也看看 [zig 圣经](https://course.ziglang.cc/advanced/comptime) 中和 `comptime` 有关的部分，写的很好）

下面我介绍一下 zoop 中用到的 `comptime` 一些技巧，相信会对大家今后使用 zig 有帮助。
## `struct` 很万能
`comptime` 编程中，`struct` 是你最好的朋友，想在不同的 `comptime` 函数之间传递数据，最方便的方式，就是通过构造一个 `struct`，把想传递的数据通过 `pub const xxx = ...` 的方式传递出去，通过 `struct` 保存数据最好的地方，就在于这个数据在运行时也是可用的 （`struct` 中的常量，是保存在 exe 的 `.data` 区，运行时可见），[zoop.tuple](https://zhuyadong.github.io/zoop-docs/reference/tuple) 就是通过这个方法实现的。

## 动态构造 `struct` 的字段，用 `@Type()`
网上好像很少有关于 `@Type()` 的使用说明，一般都是通过看 `zig.std` 的代码来学习，那我这里就稍微说明一下，希望能对大家有帮助。
目前 zig 通过 `@Type()`，能动态构造的 `struct`，只有纯字段类型的 `struct` (个人理解)。构造的方法，就是先把计算好的一个 `std.builtin.Type.StructField` 数组传递给 `@Type()` 来返回一个 `struct`，比如以下代码：
```zig
fn GenStruct() type {
    comptime var fields:[2]std.builtin.Type.StructField = undefined;
    fields[0] = .{
        .name = "age",
        .type = i32,
        .default_value = null,
        .is_comptime = false,
        .alignment = @alignOf(i32),
    };
    fields[1] = .{
        .name = "name",
        .type = []const u8,
        .default_value = null,
        .is_comptime = false,
        .alignment = @alignOf([]const u8),
    };

    return @Type(.{
        .Struct = .{
            .layout = .auto,
            .fields = fields[0..],
            .decls = &.{},
            .is_tuple = false,
        }
    });
}

const MyStruct = GenStruct();
```
这样上面的 `MyStruct` 就相当于：
```zig
const MyStruct = struct {
    age: i32,
    name: []const u8,
};
```
zoop 动态构造 `Vtable` 就是通过这个方法做到的，参考 [zoop.DefVtable 原理](https://zhuyadong.github.io/zoop-docs/reference/principle#DefVtable) 和 [zoop 源代码](https://github.com/zhuyadong/zoop.git)

## 动态构造 `struct` 的函数，用 `usingnamespace`
要想定义 `struct` 中的函数，理论上代码是一定要写在 `struct` 中的，目前 zig 唯一留下的一个口子，就是 `usingnamespace`，zoop 正是利用这个特性，来动态构造 `struct` 的函数。

我们回顾一下 `Base` 中定义 `setName` 方法的代码：
```zig
pub fn Fn(comptime T: type) type {
    return zoop.Method(.{
        struct {
            pub fn setName(this: *T, name: []const u8) void {
                this.cast(Base).name = name;
            }
        },
    });
}
```
这里 `zoop.Method()` 返回的是什么呢，返回的是：
```zig
struct {
    pub const value = .{
        struct {
            pub fn setName(this: *T, name: []const u8) void {
                this.cast(Base).name = name;
            }
        },
    };
}
```
通过返回一个 `struct` 的方式，在它的 `value` 常量中保存了一个 `tuple`，`tuple` 有一个带有方法 `setName` 的 `struct` 元素。众所周知，`tuple` 是可以各种组合的 （参考 [zoop.tuple](https://zhuyadong.github.io/zoop-docs/reference/tuple)），于是 zoop 通过 [zoop.Fn](https://zhuyadong.github.io/zoop-docs/reference/zoop#Fn)，比如上例中 `Child` 中的 `pub usingnamespace zoop.Fn(@This())`，把 `Child` 类型代入 `Base.Fn` 中，就相当于在 `Child` 内写了如下代码：
```zig
pub usingnamespace struct {
            pub fn setName(this: *Child, name: []const u8) void {
                this.cast(Base).name = name;
            }
        };
```
因而实现了对 `Base.setName()` 方法的继承。

## 运行时根据名字找 `Vtable` 和父类指针
这个功能的实现又引入了 zig 中一个很有用的标准库功能 `std.StaticStringMap`。这个函数能构造一个编译时的静态哈希表。就像上面我们说到的，想让编译时的数据能在运行时使用，只要把它放在 `struct` 中就行了 （其实是只要被 `struct` 中的常量或者函数引用就行）。我从 zoop 中抄一段代码大家一看就明白：
```zig
/// 返回一个函数，函数的功能是输入接口名，返回针对T的该接口的 Vtable
fn getVtableFunc(comptime T: type) VtableFunc {
    // 收集T实现的所有接口
    const ifaces = tuple.Append(.{IObject}, Interfaces(T)).value;

    // 建立接口名到 Vtable 的哈希表
    const kvs = comptime build_kvs: {
        const KV = struct { []const u8, *IObject.Vtable };
        var kvs_array: [ifaces.len]KV = undefined;
        for (ifaces, 0..) |iface, i| {
            kvs_array[i] = .{ @typeName(iface), @ptrCast(makeVtable(T, RealVtable(iface))) };
        }
        break :build_kvs kvs_array[0..];
    };
    const map = std.StaticStringMap(*IObject.Vtable).initComptime(kvs);

    // 返回查表函数
    return &(struct {
        pub fn func(ifacename: []const u8) ?*IObject.Vtable {
            return map.get(ifacename);
        }
    }).func;
}
```
上面是找 `Vtable` 的实现，找父类指针的实现原理是一样的，大家可以去看 zoop 源代码了解细节。